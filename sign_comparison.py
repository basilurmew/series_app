"""Модуль, в котором реализрованы признаки сходимости численных рядов"""import sympy as spfrom constants import alphabetfrom series import Seriesfrom sympy.calculus.util import continuous_domainclass Solution:    """    Класс для представления,хранения полученных ответов из признаков    """    def __init__(self, ans, steps):        """        Метод инициализации класса Solution        Args:            ans (int): 1 - сходтися, -1 - расходится, 0 - нужны доп ислледовия            steps (list): список промежуточными результатами        """        self.ans = ans        self.steps = steps        if ans == 1:            self.res ="Этот ряд сходится"        elif ans == -1:            self.res = "Этот ряд расходится"        elif ans == 0:            self.res = "Думаем дальше"        else:            self.res = "Не выполняются условия для применения интегрального признака"    def get_ans(self):        return self.ans    def get_steps(self):        return self.steps    def get_res(self):        return  self.resdef nth_test(s):    """    Функция, которая является необходимым признаком сходимости    численного ряда    Args:        s (Series): Числленный ряд    Returns:        Solution:    """    steps_list = ["\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + "(a_{" + s.get_str_var() + "})"]    limit = sp.limit(s.get_expr(),s.get_var(), float("inf"))    steps_list.append(s.get_str_expr())    steps_list.append(str(limit))    if str(limit.as_expr()) == "0":        return Solution(0, steps_list)    else:        return Solution(-1,steps_list)def ignore_constants(expr):    """    Функция игнирования констант    """    if isinstance(expr, sp.Mul):        if isinstance(expr.args[0], sp.Integer):            return expr.args[1]    return exprdef is_harmonic(s):    """    Функция, которая проверяет является ли данный числовой ряд обобщенно гармоническим    Args:        s (Series): числовой ряд    Returns:        bool: True - является обобщенно гармоническим, False - не является    """    expr = ignore_constants(s.get_expr())    if isinstance(expr.args[0], sp.Symbol) and isinstance(expr.args[1], sp.Integer):            return True    else:        return Falsedef is_harmonic_test(s):    """    Функция, которая проверяет, сходится ли данный числовой ряд как обобщенно гармонический    Args:        s (Series): числовой ряд    Returns:        Solution:    """    if is_harmonic(s):        expr = ignore_constants(s.get_expr())        if expr.args[-1] >= -1:            return Solution(-1, ["\\[α ≤ 1"])        else:            return Solution(1, ["\\[α ≥ 1"])    return Solution(0, ["\\["])def is_geometric(s):    """    Функция, которая проверяет является ли данный числовой ряд геометрическим    Args:        s (Series): числовой ряд    Returns:        bool: True - является геометрическим, False - не является    """    expr = ignore_constants(s.get_expr())    return  isinstance(expr, sp.Pow) and expr.args[-1] == s.get_var()def is_geometric_test(s):    """    Функция, которая проверяет, сходится ли данный числовой ряд как геометрический,     если он геометрический    Args:        s (Series): числовой ряд    Returns:        Solution:    """    if is_geometric(s):        expr = ignore_constants(s.get_expr())        q = float(expr.args[0])        if abs(q) < 1:            return Solution(1, ["\\[q < 1"])        else:            return Solution(-1, ["\\[q > 1"])    else:        return Solution(0,["\\["])def is_positive(s):    """    Функция проверяет, ялвяется ли численный ряд положительным    Args:        s (Series): числовой ряд    Returns:        bool: True - положительный, False - неположительный    """    return sp.limit(sp.sign(s.get_expr()), s.get_var(), float("inf")) == 1def change_n(s):    """    Функция преобразует в строке n -> n + 1    Args:        s (Series): Численный ряд    Returns:        str: Измененная строка    """    var = s.get_str_var()    expr = " " + s.get_str_expr() + " "    new_expr = ""    for i in range(1, len(expr) - 1):        if expr[i] == var and expr[i - 1] not in alphabet and expr[i + 1] not in alphabet:            new_expr += "(" + var + " + 1)"        else:            new_expr += expr[i]    return "(" + new_expr + ")"def is_dalamber_test(s):    """    Функция, которая является признаком Даламбера    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + "({{a_{" + s.get_str_var() + "}}\over{{a_{" + s.get_str_var() +"+1}}}})" )    a_next = sp.sympify(change_n(s))    ratio = sp.simplify(s.get_expr()/ a_next)    steps_list.append("(" + s.get_str_expr() +")" + " / "  +"(" +  str(a_next) + ")")    steps_list.append(str(ratio))    simp = sp.sympify(sp.expand(ratio))    if simp.as_expr() != ratio.as_expr():        steps_list.append(str(simp))    #sp.pretty_print(sp.sympify(ratio))    try:        limit = float(sp.limit(ratio, s.get_var(), float("inf")))        steps_list.append(str(limit))        if limit > 1:            return Solution(1, steps_list)        elif limit < 1:            return Solution(-1, steps_list)        else:            return Solution(0, steps_list)    except:        return Solution(0, steps_list)def is_cauchy_test(s):    """    Функция, которая является  радикальным признаком Коши    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    #\[\lim\limits_{n\to\infty} \sqrt[n]{a_{n}}\]    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + "\\sqrt[" + s.get_str_var() + "]{a_{" + s.get_str_var() + "}}")    expr = sp.simplify(sp.Pow(s.get_expr(), sp.sympify("1/" + "(" + s.get_str_var() + ")")))    steps_list.append(expr)    simp = sp.expand(expr)    print(simp)    if simp.as_expr() != expr.as_expr():        steps_list.append(simp)    try:        limit = float(sp.limit(expr, s.get_var(), float("inf")))        steps_list.append(str(limit))        if limit < 1:            return Solution(1, steps_list)        elif limit > 1:            return Solution(-1,steps_list)        else:            return Solution(0, steps_list)    except:        return Solution(0, steps_list)#Raabe signdef is_raabe_test(s):    """    Функция, которая является признаком Раабе    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    a_next = sp.sympify(change_n(s))    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + s.get_str_var() + "(({{a_{" + s.get_str_var() + "}}\over{{a_{" + s.get_str_var() + " + 1}}}}) - 1)")    ratio = sp.simplify(s.get_var() * (s.get_expr() / a_next - sp.Integer("1")))    expr = s.get_var() * (s.get_expr() / (a_next) - sp.Integer(1))    steps_list.append(str(expr))    simp = sp.expand(expr)    if simp.as_expr() != expr.as_expr():        steps_list.append(str(simp))    try:        limit = float(sp.limit(ratio, s.get_var(), float("inf")))        steps_list.append(str(limit))        #print(limit)        if limit > 1:            return Solution(1, steps_list)        elif limit < 1:            return Solution(-1, steps_list)        else:            return Solution(0,steps_list)    except:        return Solution(0, steps_list)#bertran signdef is_bertran_test(s):    """    Функция, которая является признаком Бертрана    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    a_next = sp.sympify(change_n(s))    steps_list.append("\\[ \\lim\\limits_{" + s.get_str_var() +  "\\to\\infty} ln(" + s.get_str_var()  + ")*(" + s.get_str_var()  + "*({{a_{" + s.get_str_var()  + "}}\over{a_{" + s.get_str_var() + "+1}}} - 1) - 1)")    expr = sp.simplify(sp.log(s.get_var()) *sp.simplify(s.get_var() * (s.get_expr() / a_next - sp.Integer("1")) - sp.Integer("1")))    steps_list.append(str(expr))    try:        limit = float(sp.limit(expr, s.get_var(), float("inf")))        steps_list.append(str(limit))        if limit > 1:            return Solution(1,steps_list)        elif limit < 1:            return Solution(-1, steps_list)        else:            return Solution(0, steps_list)    except:        return Solution(0, steps_list)def is_monotonically_nonincreasing(s):    """    Функция, которая проверяет, что функция монотонно убывает    Args:        s (Series): Числовой ряд    Returns:        bool:    """    d_n = sp.diff(s.get_expr())    value = sp.limit(sp.sign(d_n), s.get_var(), float("inf"))    if value == -1:        return True    else:        return Falsedef is_monotonically_increasing(s):    """    Функция, которая проверяет, что функция монотонно возрастает    Args:        s (Series): Числовой ряд    Returns:        bool:    """    d_n = sp.diff(s.get_expr())    value = sp.limit(sp.sign(d_n), s.get_var(), float("inf"))    if value == 1:        return True    else:        return Falsedef is_continuity(s):    """    Функция, которая проверяет, что функция непрерывна от 1 до inf    Args:        s (Series): Числовой ряд    Returns:        bool:    """    interval = continuous_domain(s.get_expr(), s.get_var(), sp.Range(s.get_limits()[0], "oo",1))    return interval == sp.Range(s.get_limits()[0], "oo", 1)def check_statement(s):    """    Функция, которая проверяет, что выполяеются все условия,    необходимые для интегрального признака Коши    Args:        s (Series): Числовой ряд    Returns:        bool: True - выполняются, False - невыполняются    """    return is_positive(s) and is_monotonically_nonincreasing(s) and is_continuity(s)def is_integral_test(s):    """    Функция, которая является интегральным признаком Коши    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    global steps_list    if check_statement(s):        print("Все условия для приминения Интегрального признака Коши выполнены")        try:            steps_list = []            integral = sp.integrate(s.get_expr(), (s.get_var(), s.get_limits()[0], float("inf")))            if integral < float("inf"):                return Solution(1, steps_list)            else:                return Solution(-1, steps_list)        except:            return Solution(0, steps_list)    else:        print("Все условия для приминения Интегрального признака Коши не выполнены, данный признак не подходит для исследования ряда ")        return Solution(0, list())def is_gauss_test(s):    """    Функция, которая является признаком Гаусса    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    dalamber = is_dalamber_test(s)    if dalamber.ans == 1:        return Solution(1, ['λ > 1'])    elif dalamber.ans == -1:        return Solution(-1, ['λ < 1'])    else:        raabe = is_raabe_test(s)        if raabe.ans == 1:            return Solution(1, ['λ = 1, μ > 1'])        elif raabe.ans == -1:            return Solution(-1, ['λ = 1, μ < 1'])        else:            bertran = is_bertran_test(s)            if bertran.ans == -1:                return Solution(-1, ['λ = 1, μ = 1'])            else:                return Solution(0, ["Неопределено"])def is_signalternating(s):    """    Функция, которая определяет, является ли числовой ряд знакочередующимся    Args:        s (Series): Числовой ряд    Returns:        bool: True - знакочередующийся, False - незнакочередующийся    """    n = 20    an_list = [s.get_expr().subs(s.get_var(), i) for i in range(s.get_limits()[0], s.get_limits()[0] + n)]    for i in range(len(an_list) - 1):        if an_list[i] * an_list[i + 1] >= 0:            return False    return Truedef is_leibniz_test(s):    """    Функция, которая является признаком Лейбница    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    global new_s    if is_signalternating(s):        power_list = []        #пока steps_list - пустой        steps_list = []        for i in s.get_expr().args:            if isinstance(i, sp.Pow):                power_list.append(i)        for i in power_list:            if isinstance(i.args[0],sp.Integer) and i.args[0] < 0:                expr = s.get_expr().replace(i,1)                new_s = Series(expr,s.get_str_var())                break        try:            if is_monotonically_nonincreasing(new_s):                limit = float(sp.limit(new_s.get_expr(), new_s.get_var(),float("inf")))                if limit == 0:                    return Solution(1, steps_list)                else:                    return Solution(0, steps_list)            else:                return Solution(0,steps_list)        except:            return Solution(0, steps_list)    else:        return Solution(0, list())def is_dirichlet_test(s:Series):    """    Функция, которая является признаком Дирихле    a - монотонно и стремится к нулю    последовательность частичных сумм b - ограничена    Args:        s(Series): числовой ряд    Returns:        Solution:    """    #в основном сюда попадают ряды, которые содержат в себе sin and cos    if isinstance(s.get_expr(), sp.Mul):        pass    else:        return Solution(0, list("Признак Дирихле в данном случае не может быть использован"))def ignore_mul_constants(arr):    "Метод для удаления константы, так как она не повлияет на сходимость ряда"    new_arr = []    for i in arr:        if isinstance(i,(sp.Integer,sp.Rational,sp.Float)):            continue        new_arr.append(i)    expr = sp.Integer(1)    for i in new_arr:        expr *= i    return exprdef is_abel_test(s:Series):    """    Фукнция, которая является признаком Абеля    a - мотононна и ограничена    ряд b - сходится    Args:        s(Series): числовой ряд    Returns:        Solution:    """#s = sp.sympify("((7*n + 1)/(6*n + 5))**(3*n + 2)")# s = sp.sympify("(n) * 1/n")#print(is_dalamber_test(Series(s,"n")).get_steps())