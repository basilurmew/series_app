"""Модуль, в котором реализрованы признаки сходимости численных рядов"""import sympy as spfrom constants import alphabetfrom series import Seriesfrom sympy.calculus.util import continuous_domainfrom tree_form import *def str_to_tex(expression):    expr = sp.sympify(expression)    latex_str = sp.latex(expr)    return latex_strclass Solution:    """    Класс для представления,хранения полученных ответов из признаков    """    def __init__(self, ans, steps):        """        Метод инициализации класса Solution        Args:            ans (int): 1 - сходтися, -1 - расходится, 0 - нужны доп ислледовия            steps (list): список промежуточными результатами        """        self.ans = ans        self.steps = steps        if ans == 1:            self.res ="Этот ряд сходится"        elif ans == -1:            self.res = "Этот ряд расходится"        elif ans == 0:            self.res = "Думаем дальше"        else:            self.res = "Не выполняются условия для применения интегрального признака"    def get_ans(self):        return self.ans    def get_steps(self):        return self.steps    def get_res(self):        return  self.resdef nth_test(s):    """    Функция, которая является необходимым признаком сходимости    численного ряда    Args:        s (Series): Числленный ряд    Returns:        Solution:    """    steps_list = []    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + "(a_{" + s.get_str_var() + "})")    limit = sp.limit(s.get_expr(),s.get_var(), float("inf"))    steps_list.append(s.get_str_expr())    try:        if str(limit.as_expr()) == "0":            steps_list.append("0")            return Solution(0, steps_list)        elif limit < float("inf"):            steps_list.append(str(limit))            return Solution(-1,steps_list)        elif str(limit) =="oo":            steps_list.append(str(limit))            return Solution(-1,steps_list)    except:        steps_list.append("indeterminate")        return Solution(0, steps_list)def ignore_constants(expr):    """    Функция игнирования констант    """    if isinstance(expr, sp.Mul):        if isinstance(expr.args[0], sp.Integer):            return expr.args[1]    return exprdef is_harmonic(s):    """    Функция, которая проверяет является ли данный числовой ряд обобщенно гармоническим    Args:        s (Series): числовой ряд    Returns:        bool: True - является обобщенно гармоническим, False - не является    """    expr = ignore_constants(s.get_expr())    if (isinstance(expr.args[0],sp.Symbol) and isinstance(expr.args[1],sp.Integer)):            return True    else:        return Falsedef is_harmonic_test(s):    """    Функция, которая проверяет, сходится ли данный числовой ряд как обобщенно гармонический    Args:        s (Series): числовой ряд    Returns:        Solution:    """    if is_harmonic(s):        expr = ignore_constants(s.get_expr())        if expr.args[-1] >= -1:            return Solution(-1, ["\\[α ≤ 1"])        else:            return Solution(1, ["\\[α ≥ 1"])    return Solution(0, ["\\["])def is_geometric(s):    """    Функция, которая проверяет является ли данный числовой ряд геометрическим    Args:        s (Series): числовой ряд    Returns:        bool: True - является геометрическим, False - не является    """    expr = ignore_constants(s.get_expr())    return  isinstance(expr, sp.Pow) and expr.args[-1] == s.get_var()def is_geometric_test(s):    """    Функция, которая проверяет, сходится ли данный числовой ряд как геометрический,     если он геометрический    Args:        s (Series): числовой ряд    Returns:        Solution:    """    if is_geometric(s):        expr = ignore_constants(s.get_expr())        q = float(expr.args[0])        if abs(q) < 1:            return Solution(1, ["\\[q < 1"])        else:            return Solution(-1, ["\\[q > 1"])    else:        return Solution(0, ["\\["])def is_positive(s):    """    Функция проверяет, ялвяется ли численный ряд положительным    Args:        s (Series): числовой ряд    Returns:        bool: True - положительный, False - неположительный    """    return sp.limit(sp.sign(s.get_expr()), s.get_var(), float("inf")) == 1def change_n(s):    """    Функция преобразует в строке n -> n + 1    Args:        s (Series): Численный ряд    Returns:        str: Измененная строка    """    var = s.get_str_var()    expr = " " + s.get_str_expr() + " "    new_expr = ""    for i in range(1, len(expr) - 1):        if expr[i] == var and expr[i - 1] not in alphabet and expr[i + 1] not in alphabet:            new_expr += "(" + var + " + 1)"        else:            new_expr += expr[i]    return "(" + new_expr + ")"def is_dalamber_test(s):    """    Функция, которая является признаком Даламбера    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + "({{a_{" + s.get_str_var() + "}}\over{{a_{" + s.get_str_var() +"+1}}}})" )    a_next = sp.sympify(change_n(s))    ratio = sp.simplify(s.get_expr()/ a_next)    steps_list.append("(" + s.get_str_expr() +")" + " / "  +"(" +  str(a_next) + ")")    steps_list.append(str(ratio))    simp = sp.sympify(sp.expand(ratio))    if simp.as_expr() != ratio.as_expr():        steps_list.append(str(simp))    #sp.pretty_print(sp.sympify(ratio))    try:        limit = sp.limit(ratio, s.get_var(), float("inf"))        if limit > 1:            steps_list.append(str(limit))            return Solution(1, steps_list)        elif limit < 1:            steps_list.append(str(limit))            return Solution(-1, steps_list)        elif limit == 1:            steps_list.append(str(limit))            return Solution(0, steps_list)        else:            steps_list.append("indeterminate")            return Solution(0, steps_list)    except:        steps_list.append("indeterminate")        return Solution(0, steps_list)def is_cauchy_test(s):    """    Функция, которая является  радикальным признаком Коши    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + "\\sqrt[" + s.get_str_var() + "]{a_{" + s.get_str_var() + "}}")    expr = sp.simplify(sp.Pow(s.get_expr(), sp.sympify("1/" + "(" + s.get_str_var() + ")")))    steps_list.append(str(expr))    try:        limit = sp.limit(expr, s.get_var(), float("inf"))        if limit < 1:            return Solution(1, steps_list)        elif limit > 1:            return Solution(-1,steps_list)        elif limit == 1:            steps_list.append(str(limit))            return Solution(0, steps_list)        else:            steps_list.append("indeterminate")            return Solution(0, steps_list)    except:        steps_list.append("indeterminate")        return Solution(0, steps_list)#Raabe signdef is_raabe_test(s):    """    Функция, которая является признаком Раабе    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    a_next = sp.sympify(change_n(s))    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + s.get_str_var() + "(({{a_{" + s.get_str_var() + "}}\over{{a_{" + s.get_str_var() + " + 1}}}}) - 1)")    ratio = sp.simplify(s.get_var() * (s.get_expr() / (a_next) - sp.Integer("1")))    expr = s.get_var() * (s.get_expr() / (a_next) - sp.Integer(1))    steps_list.append(str(expr))    try:        limit = sp.limit(ratio, s.get_var(), float("inf"))        #print(limit)        if limit > 1:            steps_list.append(str(limit))            return Solution(1, steps_list)        elif limit < 1:            steps_list.append(str(limit))            return Solution(-1, steps_list)        elif limit == 1:            steps_list.append(str(limit))            return Solution(0, steps_list)        else:            steps_list.append("indeterminate")            return Solution(0, steps_list)    except:        steps_list.append("indeterminate")        return Solution(0, steps_list)#bertran signdef is_bertran_test(s):    """    Функция, которая является признаком Бертрана    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    a_next = sp.sympify(change_n(s))    steps_list.append("\\[ \\lim\\limits_{" + s.get_str_var() +  "\\to\\infty} \\log(" + s.get_str_var()  + ")(" + s.get_str_var()  + "({{a_{" + s.get_str_var()  + "}}\over{a_{" + s.get_str_var() + "+1}}} - 1) - 1)")    expr = sp.simplify(sp.log(s.get_var()) *sp.simplify(s.get_var() * (s.get_expr() / a_next - sp.Integer("1")) - sp.Integer("1")))    steps_list.append(str(expr))    try:        limit = sp.limit(expr, s.get_var(), float("inf"))        if limit > 1:            steps_list.append(str(limit))            return Solution(1,steps_list)        elif limit < 1:            steps_list.append(str(limit))            return Solution(-1, steps_list)        elif limit == 1:            steps_list.append(str(limit))            return Solution(0, steps_list)        else:            steps_list.append("indeterminate")            return Solution(0, steps_list)    except:        steps_list.append("indeterminate")        return Solution(0, steps_list)def is_monotonically_nonincreasing(s):    """    Функция, которая проверяет, что функция монотонно убывает    Args:        s (Series): Числовой ряд    Returns:        bool:    """    d_n = sp.diff(s.get_expr())    value = sp.limit(sp.sign(d_n), s.get_var(), float("inf"))    if value == -1:        return True    else:        return Falsedef is_monotonically_increasing(s):    """    Функция, которая проверяет, что функция монотонно возрастает    Args:        s (Series): Числовой ряд    Returns:        bool:    """    d_n = sp.diff(s.get_expr())    value = sp.limit(sp.sign(d_n), s.get_var(), float("inf"))    if value == 1:        return True    else:        return Falsedef is_continuity(s):    """    Функция, которая проверяет, что функция непрерывна от 1 до inf    Args:        s (Series): Числовой ряд    Returns:        bool:    """    interval = continuous_domain(s.get_expr(), s.get_var(), sp.Range(s.get_limits()[0] + 1, "oo",1))    return interval == sp.Range(s.get_limits()[0] + 1, "oo", 1)def check_statement(s):    """    Функция, которая проверяет, что выполяеются все условия,    необходимые для интегрального признака Коши    Args:        s (Series): Числовой ряд    Returns:        bool: True - выполняются, False - невыполняются    """    return is_positive(s) and is_monotonically_nonincreasing(s) and is_continuity(s)def is_integral_test(s):    """    Функция, которая является интегральным признаком Коши    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    if check_statement(s):        print("Все условия для приминения Интегрального признака Коши выполнены")        try:            ss = str_to_tex(s.get_str_expr())            print(ss,"LLLLLLLLLLL")            steps_list = ["\[\int\limits_{2}^{+\infty}" + f'{ss} d' + s.get_str_var()]            integral = sp.integrate(s.get_expr(), (s.get_var(), s.get_limits()[0] + 1, float("inf")))            steps_list[0] = steps_list[0] + " = "+  str_to_tex(integral) +  " \]"            print(integral)            if integral < float("inf"):                return Solution(1, steps_list)            else:                return Solution(-1, steps_list)        except:            return Solution(0, steps_list)    else:        print("Все условия для приминения Интегрального признака Коши не выполнены, данный признак не подходит для исследования ряда ")        return Solution(0, [str_to_tex('intederminate')])def is_gauss_test(s):    """    Функция, которая является признаком Гаусса    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    dalamber = is_dalamber_test(s)    if dalamber.ans == 1:        return dalamber    elif dalamber.ans == -1:        return dalamber    else:        raabe = is_raabe_test(s)        if raabe.ans == 1:            return raabe        elif raabe.ans == -1:            return raabe        else:            bertran = is_bertran_test(s)            if bertran.ans == -1:                return bertran            else:                return Solution(0, "Неопределено")def is_signalternating(s):    """    Функция, которая определяет, является ли числовой ряд знакочередующимся    Args:        s (Series): Числовой ряд    Returns:        bool: True - знакочередующийся, False - незнакочередующийся    """    n = 20    an_list = [s.get_expr().subs(s.get_var(), i) for i in range(s.get_limits()[0], s.get_limits()[0] + n)]    for i in range(len(an_list) - 1):        if an_list[i] * an_list[i + 1] >= 0:            return False    return Truedef is_leibniz_test(s):    """    Функция, которая является признаком Лейбница    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    if is_signalternating(s):        power_list = []        #пока steps_list - пустой        steps_list = []        for i in s.get_expr().args:            if isinstance(i, sp.Pow):                power_list.append(i)        for i in power_list:            if isinstance(i.args[0],sp.Integer) and i.args[0] < 0:                expr = s.get_expr().replace(i,1)                new_s = Series(expr,s.get_str_var())                break        try:            if is_monotonically_nonincreasing(new_s):                limit = float(sp.limit(new_s.get_expr(), new_s.get_var(),float("inf")))                if limit == 0:                    return Solution(1, steps_list)                else:                    return Solution(0, steps_list)            else:                return Solution(0,steps_list)        except:            return Solution(0, steps_list)    else:        return Solution(0, list())def is_dirichlet_test(s:Series):    """    Функция, которая является признаком Дирихле    a - монотонно и стремится к нулю    последовательность частичных сумм b - ограничена    Args:        s(Series): числовой ряд    Returns:        Solution:    """    if isinstance(s.get_expr(), sp.Mul):        if len(s.get_expr().args) == 0:            return Solution(0,list())        elif len(s.get_expr().args) == 1:            if isinstance(s.get_expr(), (sp.sin, sp.cos)):                b = s.get_expr()                a = sp.sympify("1")            else:                return Solution(0, list())        else:            for i in s.get_expr().args:                if isinstance(i, (sp.cos,sp.sin)):                    a = s.get_expr() / i                    b = i                    break                else:                    return Solution(0, list())    else:        return Solution(0, list())    try:        limit = float(sp.limit(a, s.get_var(),float("inf")))        if limit == 0:            if is_monotonically_increasing(Series(a, s.get_str_var())) or is_monotonically_nonincreasing(Series(a, s.get_str_var())):                if isinstance((ignore_constants(b)), (sp.cos, sp.sin)):                    return Solution(1, list())                else:                    return Solution(0, list())            else:                return Solution(0, list())        else:            return Solution(0, list())    except:        return Solution(0, list())def is_abel_test(s:Series):    """    Фукнция, которая является признаком Абеля    a - мотононна и ограничена    ряд b - сходится    Args:        s(Series): числовой ряд    Returns:        Solution:    """    # if isinstance(s.get_expr(), sp.Mul):    #     a = s.get_expr().args[0]    #     b = s.get_expr().args[-1]    # else:    #     return Solution(0, list())    # try:    #     limit = int(sp.limit(a.get_expr(), a.get_var(), float("inf")))    #     if is_monotonically_increasing(a) or is_monotonically_nonincreasing(a):    #         return Solution(1, list())    #     else:    #         return Solution(0, list())    # except:    #     return Solution(0, list())    return Solution(0, list())#s = sp.sympify("((7*n + 1)/(6*n + 5))**(3*n + 2)")# s = sp.sympify("(n) * 1/n")#print(is_dalamber_test(Series(s,"n")).get_steps())#print(is_integral_test(Series(sp.sympify("1/(n*log(n)**2)"),"n", limits=(2,float("inf")))).get_steps())