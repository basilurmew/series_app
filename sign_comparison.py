"""Модуль, в котором реализрованы признаки сходимости численных рядов"""import sympy as spfrom constants import alphabetfrom series import Seriesfrom sympy.calculus.util import continuous_domaindef nth_test(s):    """    Функция, которая является необходимым признаком сходимости    численного ряда    Args:        s (Series): Числленный ряд    Returns:        Solution:    """    steps_list = []    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + "(a_{" + s.get_str_var() + "})")    limit = sp.limit(s.get_expr(),s.get_var(), float("inf"))    steps_list.append(s.get_str_expr())    steps_list.append(str(limit))    if str(limit.as_expr()) == "0":        return Solution(0, steps_list)    else:        return Solution(-1,steps_list)def ignore_constants(expr):    """    Функция игнирования констант    """    if isinstance(expr, sp.Mul):        if isinstance(expr.args[0], sp.Integer):            return expr.args[1]    return exprdef is_harmonic(s):    """    Функция, которая проверяет является ли данный числовой ряд обобщенно гармоническим    Args:        s (Series): числовой ряд    Returns:        bool: True - является обобщенно гармоническим, False - не является    """    expr = ignore_constants(s.get_expr())    if (isinstance(expr.args[0],sp.Symbol) and isinstance(expr.args[1],sp.Integer)):            return True    else:        return Falsedef harmonic_test(s):    """    Функция, которая проверяет, сходится ли данный числовой ряд как обобщенно гармонический    Args:        s (Series): числовой ряд    Returns:        bool: True - сходится, False - расходится    """    if is_harmonic(s):        expr = ignore_constants(s.get_expr())        if expr.args[-1] >= -1:            return False        else:            return True    return Falsedef is_geometric(s):    """    Функция, которая проверяет является ли данный числовой ряд геометрическим    Args:        s (Series): числовой ряд    Returns:        bool: True - является геометрическим, False - не является    """    expr = ignore_constants(s.get_expr())    return  isinstance(expr, sp.Pow) and expr.args[-1] == s.get_var()def geometric_test(s):    """    Функция, которая проверяет, сходится ли данный числовой ряд как геометрический    Args:        s (Series): числовой ряд    Returns:        bool: True - сходится, False - расходится    """    if is_geometric(s):        expr = ignore_constants(s.get_expr())        q = float(expr.args[0])        return abs(q) < 1    else:        return Falsedef is_positive(s):    """    Функция проверяет, ялвяется ли численный ряд положительным    Args:        s (Series): числовой ряд    Returns:        bool: True - положительный, False - неположительный    """    return sp.limit(sp.sign(s.get_expr()), s.get_var(), float("inf")) == 1def change_n(s):    """    Функция преобразует в строке n -> n + 1    Args:        s (Series): Численный ряд    Returns:        str: Измененная строка    """    var = s.get_str_var()    expr = " " + s.get_str_expr() + " "    new_expr = ""    for i in range(1, len(expr) - 1):        if expr[i] == var and expr[i - 1] not in alphabet and expr[i + 1] not in alphabet:            new_expr += "(" + var + " + 1)"        else:            new_expr += expr[i]    return "(" + new_expr + ")"def is_dalamber_test(s):    """    Функция, которая является признаком Даламбера    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + "({{a_{" + s.get_str_var() + "}}\over{{a_{" + s.get_str_var() +"+1}}}})" )    a_next = sp.sympify(change_n(s))    ratio = sp.simplify(s.get_expr()/ a_next)    steps_list.append("(" + s.get_str_expr() +")" + " / "  +"(" +  str(a_next) + ")")    steps_list.append(str(ratio))    #sp.pretty_print(sp.sympify(ratio))    try:        limit = float(sp.limit(ratio, s.get_var(), float("inf")))        steps_list.append(str(limit))        if limit < 1:            return Solution(1, steps_list)        elif limit > 1:            return Solution(-1, steps_list)        else:            return Solution(0, steps_list)    except ValueError:        raise ValueError("Error")def is_cauchy_test(s):    """    Функция, которая является  радикальным признаком Коши    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    steps_list.append(["a", s.get_str_var()])    expr = sp.simplify(sp.Pow(s.get_expr(), sp.sympify("1/" + "(" + s.get_str_var() + ")")))    steps_list.append(str(expr))    try:        limit = float(sp.limit(expr, s.get_var(), float("inf")))        steps_list.append(str(limit))        if limit < 1:            return Solution(1, steps_list)        elif limit > 1:            return Solution(-1,steps_list)        else:            return Solution(0, steps_list)    except:        raise ValueError("Error")#Raabe signdef is_raabe_test(s):    """    Функция, которая является признаком Раабе    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    a_next = sp.sympify(change_n(s))    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + s.get_str_var() + "({{a_{" + s.get_str_var() + "}}\over{{a_{" + s.get_str_var() + " + 1}}}} - 1)")    ratio = sp.simplify(s.get_var() * (s.get_expr() / (a_next) - sp.Integer("1")))    steps_list.append(str(s.get_var() * (s.get_expr() / a_next - sp.Integer(1))))    try:        steps_list.append(str(ratio))        limit = float(sp.limit(ratio, s.get_var(), float("inf")))        steps_list.append(str(limit))        #print(limit)        if limit > 1:            return Solution(1, steps_list)        elif limit < 1:            return Solution(-1, steps_list)        else:            return Solution(0,steps_list)    except ValueError:        raise ValueError("Error")#bertran signdef is_bertran_test(s):    """    Функция, которая является признаком Бертрана    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    a_next = sp.sympify(change_n(s))    expr = sp.simplify(sp.log(s.get_var()) *sp.simplify(s.get_var() * (s.get_expr() / a_next - sp.Integer("1")) - sp.Integer("1")))    try:        limit = float(sp.limit(expr, s.get_var(), float("inf")))        steps_list.append(str(limit))        if limit > 1:            return Solution(1,steps_list)        elif limit < 1:            return Solution(-1, steps_list)        else:            return Solution(0, steps_list)    except ValueError:        raise ValueError("Error")def is_integral_test(s):    """    Функция, которая является интегральным признаком Коши    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    def check_statement(s):        """        Функция, которая проверяет, что выполяеются все условия,        необходимые для интегрального признака Коши        Args:            s (Series): Числовой ряд        Returns:            bool: True - выполняются, False - невыполняются        """        def is_monotonically_nonincreasing():            """            Функция, которая проверяет, что функция монотонно убывает            Returns:                bool:            """            d_n = sp.diff(s.get_expr())            value = sp.limit(sp.sign(d_n), s.get_var(), float("inf"))            if value == -1:                return True            else:                return False        def is_continuity():            """            Функция, которая проверяет, что функция непрерывна от 1 до inf            Returns:                bool:            """            interval = continuous_domain(s.get_expr(), s.get_var(), sp.Range(s.get_limits()[0], "oo",1))            return interval == sp.Range(s.get_limits()[0], "oo", 1)        return is_positive(s) and is_monotonically_nonincreasing() and is_continuity()    if check_statement(s):        try:            integral = sp.integrate(s.get_expr(), (s.get_var(), s.get_limits()[0], float("inf")))            if isinstance(integral, (sp.Integer, sp.Float)):                return Solution(1, "Учись считать интегралы")            else:                return Solution(-1, "Учись считать интегралы")        except:            return Solution(None, "Ошибка в интегрировании")    else:        return Solution(None,"lol")def is_gauss_test(s):    """    Функция, которая является признаком Гаусса    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    dalamber = is_dalamber_test(s)    if dalamber.ans == 1:        return 'lambda > 1 ряд сходится'    elif dalamber.ans == -1:        return 'lambda < 1 ряд расходится'    else:        raabe = is_raabe_test(s)        if raabe.ans == 1:            return 'lambda = 1, mu > 1 ряд сходится'        elif raabe.ans == -1:            return 'lambda = 1, mu < 1 ряд расходится'        else:            bertran = is_bertran_test(s)            if bertran.ans == -1:                return 'lambda = 1, mu = 1 ряд расходится'            else:                return "LOL"class Solution:    """    Класс для представления,хранения полученных ответов из признаков    """    def __init__(self, ans, steps):        """        Метод инициализации класса Solution        Args:            ans (int): 1 - сходтися, -1 - расходится, 0 - нужны доп ислледовия            steps (list): список промежуточными результатами        """        self.ans = ans        self.steps = steps        if ans == 1:            self.res ="Этот ряд сходится"        elif ans == -1:            self.res = "Этот ряд расходится"        elif ans == 0:            self.res = "Думаем дальше"        else:            self.res = "Не выполняются условия для применения интегрального признака"    def get_ans(self):        return self.ans    def get_steps(self):        return self.steps    def get_res(self):        return  self.res