import sympy as spimport seriesfrom constants import alphabetfrom series import Seriesfrom sympy.calculus.util import continuous_domaindef nth_test(s:Series):    steps_list = []    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + "(a_{" + s.get_str_var() + "})")    limit = sp.limit(s.get_expr(),s.get_var(), float("inf"))    steps_list.append(s.get_str_expr())    steps_list.append(str(limit))    if str(limit.as_expr()) == "0":        return Solution(0, steps_list)    else:        return Solution(-1,steps_list)#ignoring constantsdef ignore_constants(expr):    if isinstance(expr, sp.Mul):        if isinstance(expr.args[0], sp.Integer):            return expr.args[1]    return expr#is a sign  looks like harmonic seriesdef is_harmonic(s:Series) -> bool:    expr = ignore_constants(s.get_expr())    if (isinstance(expr.args[0],sp.Symbol) and isinstance(expr.args[1],sp.Integer)):            return True    else:        return False#is a harmonic series is finitedef harmonic_test(s:Series) -> bool:    if is_harmonic(s):        expr = ignore_constants(s.get_expr())        if expr.args[-1] >= -1:            return False        else:            return True    return False#is a sign  looks like geometric seriesdef is_geometric(s:Series) -> bool:    expr = ignore_constants(s.get_expr())    return  isinstance(expr, sp.Pow) and expr.args[-1] == s.get_var()#geometric series testdef geometric_test(s:Series) -> bool:        if is_geometric(s):            expr = ignore_constants(s.get_expr())            q = float(expr.args[0])            return abs(q) < 1        else:            return False#is all sign members are positivedef is_positive(s:Series):    return sp.limit(sp.sign(s.get_expr()), s.get_var(), float("inf")) == 1#n+1 transformationdef change_n(s:Series):    var = s.get_str_var()    expr = " " + s.get_str_expr() + " "    new_expr = ""    for i in range(1, len(expr) - 1):        if expr[i] == var and expr[i - 1] not in alphabet and expr[i + 1] not in alphabet:            new_expr += "(" + var + " + 1)"        else:            new_expr += expr[i]    return "(" + new_expr + ")"# dalamber_testdef is_dalamber_test(s:Series):    steps_list = list()    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + "({{a_{" + s.get_str_var() + "}}\over{{a_{" + s.get_str_var() +"+1}}}})" )    a_next = sp.sympify(change_n(s))    ratio = sp.simplify(s.get_expr()/ a_next)    steps_list.append("(" + s.get_str_expr() +")" + " / "  +"(" +  str(a_next) + ")")    steps_list.append(str(ratio))    #sp.pretty_print(sp.sympify(ratio))    try:        limit = float(sp.limit(ratio, s.get_var(), float("inf")))        steps_list.append(str(limit))        if limit < 1:            return Solution(1, steps_list)        elif limit > 1:            return Solution(-1, steps_list)        else:            return Solution(0, steps_list)    except ValueError:        raise ValueError("Error")#Cauchy sighdef is_cauchy_test(s:Series):    steps_list = list()    steps_list.append(["a", s.get_str_var()])    expr = sp.simplify(sp.Pow(s.get_expr(), sp.sympify("1/" + "(" + s.get_str_var() + ")")))    steps_list.append(str(expr))    try:        limit = float(sp.limit(expr, s.get_var(), float("inf")))        steps_list.append(str(limit))        if limit < 1:            return Solution(1, steps_list)        elif limit > 1:            return Solution(-1,steps_list)        else:            return Solution(0, steps_list)    except:        raise ValueError("Error")#Raabe signdef is_raabe_test(s:Series):    steps_list = list()    a_next = sp.sympify(change_n(s))    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + s.get_str_var() + "({{a_{" + s.get_str_var() + "}}\over{{a_{" + s.get_str_var() + " + 1}}}} - 1)")    ratio = sp.simplify(s.get_var() * (s.get_expr() / (a_next) - sp.Integer("1")))    steps_list.append(str(s.get_var() * (s.get_expr() / a_next - sp.Integer(1))))    try:        steps_list.append(str(ratio))        limit = float(sp.limit(ratio, s.get_var(), float("inf")))        steps_list.append(str(limit))        #print(limit)        if limit > 1:            return Solution(1, steps_list)        elif limit < 1:            return Solution(-1, steps_list)        else:            return Solution(0,steps_list)    except ValueError:        raise ValueError("Error")#bertran signdef is_bertran_test(s:Series):    steps_list = list()    a_next = sp.sympify(change_n(s))    expr = sp.simplify(sp.log(s.get_var()) *sp.simplify(s.get_var() * (s.get_expr() / a_next - sp.Integer("1")) - sp.Integer("1")))    #sp.pretty_print(sp.simplify(sp.expand(ratio)))    try:        limit = float(sp.limit(expr, s.get_var(), float("inf")))        steps_list.append(str(limit))        if limit > 1:            return Solution(1,steps_list)        elif limit < 1:            return Solution(-1, steps_list)        else:            return Solution(0, steps_list)    except ValueError:        raise ValueError("Error")#integral signdef is_integral_test(s:Series):    def check_statement(s:Series):        #function checks is sign member monotomic and dicreasing        def is_monotonically_nonincreasing():            d_n = sp.diff(s.get_expr())            value = sp.limit(sp.sign(d_n), s.get_var(), float("inf"))            if value == -1:                return True            else:                return False        #function checks is sign member continuos        def is_continuity():            interval = continuous_domain(s.get_expr(), s.get_var(), sp.Range(s.get_limits()[0], "oo",1))            return interval == sp.Range(s.get_limits()[0], "oo", 1)        return is_positive(s) and is_monotonically_nonincreasing() and is_continuity()    if check_statement(s):        try:            integral = sp.integrate(s.get_expr(), (s.get_var(), s.get_limits()[0], float("inf")))            if isinstance(integral, (sp.Integer, sp.Float)):                return Solution(1, "Учись считать интегралы")            else:                return Solution(-1, "Учись считать интегралы")        except:            return Solution(None, "Ошибка в интегрировании")    else:        return Solution(None,"lol")def is_gauss_test(s:Series):    dalamber = is_dalamber_test(s)    if dalamber.ans == 1:        return 'lambda > 1 ряд сходится'    elif dalamber.ans == -1:        return 'lambda < 1 ряд расходится'    else:        raabe = is_raabe_test(s)        if raabe.ans == 1:            return 'lambda = 1, mu > 1 ряд сходится'        elif raabe.ans == -1:            return 'lambda = 1, mu < 1 ряд расходится'        else:            bertran = is_bertran_test(s)            if bertran.ans == -1:                return 'lambda = 1, mu = 1 ряд расходится'            else:                return "LOL"#class to represent result of signsclass Solution:    def __init__(self, ans, steps):        self.ans = ans        self.steps = steps        if ans == 1:            self.res ="Этот ряд сходится"        elif ans == -1:            self.res = "Этот ряд расходится"        elif ans == 0:            self.res = "Думаем дальше"        else:            self.res = "Не выполняются условия для применения интегрального признака"    def get_ans(self):        return self.ans    def get_steps(self):        return self.steps    def get_res(self):        return  self.res