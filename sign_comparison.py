"""Модуль, в котором реализрованы признаки сходимости численных рядов"""import sympy as spfrom constants import alphabetfrom series import Seriesfrom sympy.calculus.util import continuous_domainclass Solution:    """    Класс для представления,хранения полученных ответов из признаков    """    def __init__(self, ans, steps):        """        Метод инициализации класса Solution        Args:            ans (int): 1 - сходтися, -1 - расходится, 0 - нужны доп ислледовия            steps (list): список промежуточными результатами        """        self.ans = ans        self.steps = steps        if ans == 1:            self.res ="Этот ряд сходится"        elif ans == -1:            self.res = "Этот ряд расходится"        elif ans == 0:            self.res = "Думаем дальше"        else:            self.res = "Не выполняются условия для применения интегрального признака"    def get_ans(self):        return self.ans    def get_steps(self):        return self.steps    def get_res(self):        return  self.resdef nth_test(s):    """    Функция, которая является необходимым признаком сходимости    численного ряда    Args:        s (Series): Числленный ряд    Returns:        Solution:    """    steps_list = []    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + "(a_{" + s.get_str_var() + "})")    limit = sp.limit(s.get_expr(),s.get_var(), float("inf"))    steps_list.append(s.get_str_expr())    steps_list.append(str(limit))    if str(limit.as_expr()) == "0":        return Solution(0, steps_list)    else:        return Solution(-1,steps_list)def ignore_constants(expr):    """    Функция игнирования констант    """    if isinstance(expr, sp.Mul):        if isinstance(expr.args[0], sp.Integer):            return expr.args[1]    return exprdef is_harmonic(s):    """    Функция, которая проверяет является ли данный числовой ряд обобщенно гармоническим    Args:        s (Series): числовой ряд    Returns:        bool: True - является обобщенно гармоническим, False - не является    """    expr = ignore_constants(s.get_expr())    if (isinstance(expr.args[0],sp.Symbol) and isinstance(expr.args[1],sp.Integer)):            return True    else:        return Falsedef is_harmonic_test(s):    """    Функция, которая проверяет, сходится ли данный числовой ряд как обобщенно гармонический    Args:        s (Series): числовой ряд    Returns:        Solution:    """    if is_harmonic(s):        expr = ignore_constants(s.get_expr())        if expr.args[-1] >= -1:            return Solution(-1, list())        else:            return Solution(1, list())    return Solution(0, list())def is_geometric(s):    """    Функция, которая проверяет является ли данный числовой ряд геометрическим    Args:        s (Series): числовой ряд    Returns:        bool: True - является геометрическим, False - не является    """    expr = ignore_constants(s.get_expr())    return  isinstance(expr, sp.Pow) and expr.args[-1] == s.get_var()def is_geometric_test(s):    """    Функция, которая проверяет, сходится ли данный числовой ряд как геометрический,     если он геометрический    Args:        s (Series): числовой ряд    Returns:        Solution:    """    if is_geometric(s):        expr = ignore_constants(s.get_expr())        q = float(expr.args[0])        if abs(q) < 1:            return Solution(1, list())        else:            return Solution(-1, list())    else:        return Solution(0, list())def is_positive(s):    """    Функция проверяет, ялвяется ли численный ряд положительным    Args:        s (Series): числовой ряд    Returns:        bool: True - положительный, False - неположительный    """    return sp.limit(sp.sign(s.get_expr()), s.get_var(), float("inf")) == 1def change_n(s):    """    Функция преобразует в строке n -> n + 1    Args:        s (Series): Численный ряд    Returns:        str: Измененная строка    """    var = s.get_str_var()    expr = " " + s.get_str_expr() + " "    new_expr = ""    for i in range(1, len(expr) - 1):        if expr[i] == var and expr[i - 1] not in alphabet and expr[i + 1] not in alphabet:            new_expr += "(" + var + " + 1)"        else:            new_expr += expr[i]    return "(" + new_expr + ")"def is_dalamber_test(s):    """    Функция, которая является признаком Даламбера    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + "({{a_{" + s.get_str_var() + "}}\over{{a_{" + s.get_str_var() +"+1}}}})" )    a_next = sp.sympify(change_n(s))    ratio = sp.simplify(s.get_expr()/ a_next)    steps_list.append("(" + s.get_str_expr() +")" + " / "  +"(" +  str(a_next) + ")")    steps_list.append(str(ratio))    #sp.pretty_print(sp.sympify(ratio))    try:        limit = float(sp.limit(ratio, s.get_var(), float("inf")))        steps_list.append(str(limit))        if limit > 1:            return Solution(1, steps_list)        elif limit < 1:            return Solution(-1, steps_list)        else:            return Solution(0, steps_list)    except ValueError:        raise ValueError("Error")def is_cauchy_test(s):    """    Функция, которая является  радикальным признаком Коши    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    steps_list.append(["a", s.get_str_var()])    expr = sp.simplify(sp.Pow(s.get_expr(), sp.sympify("1/" + "(" + s.get_str_var() + ")")))    steps_list.append(str(expr))    try:        limit = float(sp.limit(expr, s.get_var(), float("inf")))        steps_list.append(str(limit))        if limit < 1:            return Solution(1, steps_list)        elif limit > 1:            return Solution(-1,steps_list)        else:            return Solution(0, steps_list)    except:        raise ValueError("Error")#Raabe signdef is_raabe_test(s):    """    Функция, которая является признаком Раабе    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    a_next = sp.sympify(change_n(s))    steps_list.append("\\[\\lim\\limits_{" + s.get_str_var() + "\\to\\infty}" + s.get_str_var() + "({{a_{" + s.get_str_var() + "}}\over{{a_{" + s.get_str_var() + " + 1}}}} - 1)")    ratio = sp.simplify(s.get_var() * (s.get_expr() / (a_next) - sp.Integer("1")))    steps_list.append(str(s.get_var() * (s.get_expr() / (a_next) - sp.Integer(1))))    try:        steps_list.append(str(ratio))        limit = float(sp.limit(ratio, s.get_var(), float("inf")))        steps_list.append(str(limit))        #print(limit)        if limit > 1:            return Solution(1, steps_list)        elif limit < 1:            return Solution(-1, steps_list)        else:            return Solution(0,steps_list)    except ValueError:        raise ValueError("Error")#bertran signdef is_bertran_test(s):    """    Функция, которая является признаком Бертрана    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    steps_list = list()    a_next = sp.sympify(change_n(s))    expr = sp.simplify(sp.log(s.get_var()) *sp.simplify(s.get_var() * (s.get_expr() / a_next - sp.Integer("1")) - sp.Integer("1")))    try:        limit = float(sp.limit(expr, s.get_var(), float("inf")))        steps_list.append(str(limit))        if limit > 1:            return Solution(1,steps_list)        elif limit < 1:            return Solution(-1, steps_list)        else:            return Solution(0, steps_list)    except ValueError:        raise ValueError("Error")def is_monotonically_nonincreasing(s):    """    Функция, которая проверяет, что функция монотонно убывает    Args:        s (Series): Числовой ряд    Returns:        bool:    """    d_n = sp.diff(s.get_expr())    value = sp.limit(sp.sign(d_n), s.get_var(), float("inf"))    if value == -1:        return True    else:        return Falsedef is_monotonically_increasing(s):    """    Функция, которая проверяет, что функция монотонно возрастает    Args:        s (Series): Числовой ряд    Returns:        bool:    """    d_n = sp.diff(s.get_expr())    value = sp.limit(sp.sign(d_n), s.get_var(), float("inf"))    if value == 1:        return True    else:        return Falsedef is_continuity(s):    """    Функция, которая проверяет, что функция непрерывна от 1 до inf    Args:        s (Series): Числовой ряд    Returns:        bool:    """    interval = continuous_domain(s.get_expr(), s.get_var(), sp.Range(s.get_limits()[0], "oo",1))    return interval == sp.Range(s.get_limits()[0], "oo", 1)def check_statement(s):    """    Функция, которая проверяет, что выполяеются все условия,    необходимые для интегрального признака Коши    Args:        s (Series): Числовой ряд    Returns:        bool: True - выполняются, False - невыполняются    """    return is_positive(s) and is_monotonically_nonincreasing(s) and is_continuity(s)def is_integral_test(s):    """    Функция, которая является интегральным признаком Коши    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    if check_statement(s):        try:            steps_list = []            integral = sp.integrate(s.get_expr(), (s.get_var(), s.get_limits()[0], float("inf")))            if isinstance(integral, (sp.Integer, sp.Float)):                return Solution(1, steps_list)            else:                return Solution(-1, steps_list)        except:            return Solution(0, steps_list)    else:        return Solution(0, list())def is_gauss_test(s):    """    Функция, которая является признаком Гаусса    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    dalamber = is_dalamber_test(s)    if dalamber.ans == 1:        return Solution(1, 'λ > 1')    elif dalamber.ans == -1:        return Solution(-1, 'λ < 1')    else:        raabe = is_raabe_test(s)        if raabe.ans == 1:            return Solution(1, 'λ = 1, μ > 1')        elif raabe.ans == -1:            return Solution(-1, 'λ = 1, μ < 1')        else:            bertran = is_bertran_test(s)            if bertran.ans == -1:                return Solution(-1, 'λ = 1, μ = 1')            else:                return Solution(0, "Неопределено")def is_signalternating(s):    """    Функция, которая определяет, является ли числовой ряд знакочередующимся    Args:        s (Series): Числовой ряд    Returns:        bool: True - знакочередующийся, False - незнакочередующийся    """    n = 10    an_list = [s.get_expr().subs(s.get_var(), i) for i in range(s.get_limits()[0], s.get_limits()[0] + n)]    for i in range(len(an_list) - 1):        if an_list[i] * an_list[i + 1] >= 0:            return False    return Truedef is_leibniz_test(s):    """    Функция, которая является признаком Лейбница    Args:        s (Series): Числовой ряд    Returns:        Solution:    """    if is_signalternating(s):        power_list = []        #пока steps_list - пустой        steps_list = []        for i in s.get_expr().args:            if isinstance(i, sp.Pow):                power_list.append(i)        for i in power_list:            if isinstance(i.args[0],sp.Integer) and i.args[0] < 0:                expr = s.get_expr().replace(i,1)                new_s = Series(expr,s.get_str_var())                break        try:            if is_monotonically_nonincreasing(new_s):                limit = float(sp.limit(new_s.get_expr(), new_s.get_var(),float("inf")))                if limit == 0:                    return Solution(1, steps_list)                else:                    return Solution(-1, steps_list)            else:                return Solution(-1, steps_list)        except:            return Solution(0, steps_list)    else:        return Solution(0, list())def is_dirichlet_test(a,b):    """    Функция, которая является признаком Дирихле    a - монотонно и стремится к нулю    последовательность частичных сумм b - ограничена    Args:        a (Series): нужен общий член данного ряда, для исследования на монотонность        b (Series): числовой ряд    Returns:        Solution:    """    # пока что версия в разработке    try:        limit = float(sp.limit(a.get_expr(), a.get_var(),float("inf")))        if limit == 0:            if is_monotonically_increasing(a) or is_monotonically_nonincreasing(a):                if isinstance(type(ignore_constants(b.get_expr())), (sp.cos, sp.sin)):                    return Solution(1, list())                else:                    if series_test():                        return Solution(1, list())                    else:                        return Solution(0, list())            else:                return Solution(0, list())        else:            return Solution(0, list())    except:        return Solution(0, list())def is_abel_test(a, b):    """    Фукнция, которая является признаком Абеля    a - мотононна и ограничена    ряд b - сходится    Args:        a (Series): числовой ряд        b (Series): числовой ряд    Returns:        Solution:    """    # пока что версия в разработке    try:        #если предел неконечный, то попадем в блок except, то есть нет ограниченности        limit = float(sp.limit(a.get_expr(), a.get_var(), float("inf")))        if is_monotonically_increasing(a) or is_monotonically_nonincreasing(a):            if series_test():                return Solution(1, list())            else:                return Solution(0, list())        else:            return Solution(0, list())    except:        return Solution(0, list())def series_test(b):    pass#s = sp.sympify("(-1)**(n) + (-1)**n")#print(is_leibniz_test(Series(s,"n")).get_res())